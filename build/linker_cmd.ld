
/** 
 *  
 *  The Linker Command File directs the linker where to allocate the various
 *  items that make up the application in the processor's memories.  This 
 *  includes the flash memory that contains the application software and the
 *  RAM memory used by the application as it executes.
 */

/*
 *  We bring in the core C libraries.
 */
GROUP(libgcc.a libc.a)

/*
 *  This is the basic memory layout.
 */
MEMORY
{
    FLASH (rx)           : ORIGIN = 0x08000000, LENGTH = 2048K
    SRAM (rwx)           : ORIGIN = 0x20000000, LENGTH = 192K
    CCMRAM (rwx)         : ORIGIN = 0x10000000, LENGTH = 64K
}


/*
 *  This symbol is used to initialize the system stack at start-up.
 */
_estack = ORIGIN(CCMRAM) + LENGTH(CCMRAM);

/*
 *  This is the where execution starts at reset.
 */
ENTRY(Reset_Handler)

SECTIONS
{

   ISRvectors : ALIGN(0x10)
   {      
      _vector_table_start = .;
      KEEP(*(.isr_vector))
      _vector_table_end = .;
   } > FLASH

   .text : ALIGN(0x10)
   {      
      /*
       *  This is the bulk of the application executable.
       */
      *(.text .text.* .text* .gnu.linkonce.t.*)
    
      /*
       *  The next group of sections are generated by the tool-chain when it
       *  builds the application.  These are largely derived from provided
       *  examples.
       */
      *(.rodata .rodata.* .gnu.linkonce.r.*)
      *(.glue_7)         /* glue arm to thumb code */
      *(.glue_7t)        /* glue thumb to arm code */
      *(.eh_frame)
      KEEP (*(.init))
      KEEP (*(.fini))
      . = ALIGN(4);
   } > FLASH

   /* 
    * for exception handling/unwind - some Newlib functions (in common with
    *  C++ and STDC++) use this. 
    */
   .ARM.extab :
   {
      *(.ARM.extab* .gnu.linkonce.armextab.*)
   } > FLASH

   __exidx_start = .;
   .ARM.exidx :
   {
      *(.ARM.exidx* .gnu.linkonce.armexidx.*)
   } > FLASH
   __exidx_end = .;

   .preinit_array     :
   {
      PROVIDE_HIDDEN (__preinit_array_start = .);
      KEEP (*(.preinit_array*))
      PROVIDE_HIDDEN (__preinit_array_end = .);
   } >FLASH

   .init_array :
   {
      PROVIDE_HIDDEN (__init_array_start = .);
      KEEP (*(SORT(.init_array.*)))
      KEEP (*(.init_array*))
      PROVIDE_HIDDEN (__init_array_end = .);
   } > FLASH

   .fini_array :
   {
      PROVIDE_HIDDEN (__fini_array_start = .);
      KEEP (*(.fini_array*))
      KEEP (*(SORT(.fini_array.*)))
      PROVIDE_HIDDEN (__fini_array_end = .);
   } > FLASH

   /*
    * This is the end of flash memory used for code storage.
    */
   _endText = .;
         
   /*
    *  The data segment stores all items that are initialized to non-zero
    *  value in their definitions.
    */
   .data : ALIGN(0x10)
   {
      _dataFlashStart = LOADADDR(.data);
      _dataRAMStart   = ADDR(.data);

      *(.data .data* .data.* .gnu.linkonce.d.*)
      KEEP(*(.jcr))
      *(.jcr)
      *(.igot.plt)
      *(.shdata)
      _dataRAMEnd = ALIGN(0x10);
   } > SRAM AT > FLASH
   
   .dma_memory (NOLOAD): ALIGN(0x10)
   {
      /*
       * This segment is used to buffer memory that is accessed by
       * the DMA controller. It must be in SRAM as the DMA cannot
       * access the CCMRAM.
       */
   } AT > SRAM
   
   /*
    *  The bss segment stores all items that are assumed to be initialized to
    *  zero at startup.
    */
   .bss : ALIGN(0x10)
   {
      _bssStart = .;
      *(.shbss)
      *(.bss .bss* .bss.* .gnu.linkonce.b.*)
      *(COMMON)
      . = ALIGN(0x10);
      _bssEnd = .;
   } > SRAM

   /*
    *  We put the heap and our stacks in the second ram.
    */
   _mallocHeapSize = 2K;
   _minStackSize   = 2K;
   
   .rtos_heap (NOLOAD): ALIGN(0x10)
   {
      /*
       * We define the heap used by the RTOS.  We support memory allocation
       * but not memory freeing.
       */
   } AT > CCMRAM

   .taskqueues (NOLOAD): ALIGN(0x10)
   {
      /*
       * The memory for each task's message queues is linked here.
       */
      *(_taskQueues*)
   }  AT > CCMRAM

   .taskstacks (NOLOAD): ALIGN(0x10)
   {
      /*
       * Memory for each task's stack is linked here.
       */
      *(_taskStacks*)
   }  AT > CCMRAM

   .the_heap (NOLOAD): ALIGN(0x10)
   {
      /*
       * We define a small heap for malloc.  We don't really expect it to be
       * used much.  In our application memory is only taken, it
       * is never returned.
       */
      _heap_start = .;
      . = _mallocHeapSize;
      _heap_end = .;
   } AT > CCMRAM

   .the_stack (NOLOAD): ALIGN(0x10)
   {
     /*
      * We define a stack section even though it is not used.  This really
      * exists to trap a case where we are running out of memory.
      */
      . = _minStackSize;
   } AT > CCMRAM   
}
