////////////////////////////////////////////////////////////////////////////////
//
//  Yet Another Motor Drive
//
//  MIT License
//
//  Copyright (c) 2021 Michael F. Kaufman
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//
////////////////////////////////////////////////////////////////////////////////
//
//  Provides an interface to the processor's ADC
//
//  The ADC samples the various analog inputs to the processor and provides
//  data in ADC counts.  This interface controls the ADC and provides the raw
//  ADC data to its consumers.  The consumers are responsible for converting
//  the data from ADC counts to the proper unit.
//
//  The ADC is configured to automatically sample all of its inputs based on
//  on a trigger generated by the motor PWM timer.  The sample trigger is
//  generated at a time that minimizes the noise impacts of the PWM switching
//  on the ADC inputs.
//
////////////////////////////////////////////////////////////////////////////////
#include "adc_conversions.h"
#include "adc_interface.h"
#include "config.h"
#include "global_definitions.h"
#include "gpio_interface.h"
#include "hw_definitions.h"
#include "motor_controller.h"
#include "physical_inputs.h"
#include "processor.h"
#include "tick_timers.h"

#include <string.h>
#include <stdio.h>

#include "dac_interface.h"

//
//  These are physical constants related to the ADC interface.
//
namespace ADCConstants
{
    //
    //  This is the number of ADC channels that may be sampled.  To simplify
    //  things, we sample the same number of channels on each ADC.
    //
    const uint32_t numberADCInputChannels = 4U;

    //
    //  These map the channel sequence to the values stored in the input buffers.
    //  One must be careful to pull the proper data from the proper buffer.
    //
    //  These are the ADC 1 values:
    //
    const uint32_t phaseAVoltage = 0U;
    const uint32_t phaseACurrent = 1U;
    const uint32_t analogHallA   = 2U;
    const uint32_t busVoltage    = 3U;

    //
    //  These are the ADC 2 values:
    //
    const uint32_t phaseBVoltage = 0U;
    const uint32_t phaseBCurrent = 1U;
    const uint32_t analogHallB   = 2U;
    const uint32_t busCurrent    = 3U;

    //
    //  These are the ADC 3 values:
    //
    const uint32_t phaseCVoltage = 0U;
    const uint32_t phaseCCurrent = 1U;
    const uint32_t analogHallC   = 2U;
    const uint32_t spareADC      = 3U;
}

//
//  These are the buffers used to store data as it is read from each ADC.  We
//  make sure that they are aligned and linked so that the DMA controller may
//  access them.
//
static uint32_t adc1DataBuffer[ADCConstants::numberADCInputChannels]
    __attribute__((aligned(0x10), section(".dma_memory")));
static uint32_t adc2DataBuffer[ADCConstants::numberADCInputChannels]
    __attribute__((aligned(0x10), section(".dma_memory")));
static uint32_t adc3DataBuffer[ADCConstants::numberADCInputChannels]
    __attribute__((aligned(0x10), section(".dma_memory")));

////////////////////////////////////////////////////////////////////////////////
//
//  Class constructor
//
////////////////////////////////////////////////////////////////////////////////
ADCInterface::ADCInterface()
{
    memset(adc1DataBuffer, 0U, sizeof(adc1DataBuffer));
    memset(adc2DataBuffer, 0U, sizeof(adc2DataBuffer));
    memset(adc3DataBuffer, 0U, sizeof(adc3DataBuffer));
}

////////////////////////////////////////////////////////////////////////////////
//
//  Initializes the ADC interface.  This configures the ADC and its converter.
//  It does not start the actual sampling of data.
//
////////////////////////////////////////////////////////////////////////////////
void ADCInterface::initializeADCInterface()
{
    //
    //  Now we initialize the various ADC features.  ADC initializations are
    //  broken into several steps.  The first are the "common" initializations.
    //  This includes the ADC clock divider and whether or not the ADC
    //  peripherals are linked.  For now, we use a single independent ADC.
    //
    LL_ADC_CommonInitTypeDef commonSettings;
    LL_ADC_CommonStructInit(&commonSettings);
    commonSettings.CommonClock           = LL_ADC_CLOCK_SYNC_PCLK_DIV4;
    commonSettings.Multimode             = LL_ADC_MULTI_INDEPENDENT;
    commonSettings.MultiDMATransfer      = LL_ADC_MULTI_REG_DMA_EACH_ADC;
    commonSettings.MultiTwoSamplingDelay = LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES;

    LL_ADC_CommonInit(ADCDefinitions::allADCs, &commonSettings);

    //
    //  These are specific initializations for each ADC related to the data
    //  formatting and whether or not we want the ADC to scan its inputs (we do).
    //
    LL_ADC_InitTypeDef specificSettings;
    LL_ADC_StructInit(&specificSettings);
    specificSettings.Resolution         = LL_ADC_RESOLUTION_12B;
    specificSettings.DataAlignment      = LL_ADC_DATA_ALIGN_RIGHT;
    specificSettings.SequencersScanMode = LL_ADC_SEQ_SCAN_ENABLE;

    LL_ADC_Init(ADCDefinitions::theADC1, &specificSettings);
    LL_ADC_Init(ADCDefinitions::theADC2, &specificSettings);
    LL_ADC_Init(ADCDefinitions::theADC3, &specificSettings);

    //
    //  These define the behavior of "regular" conversions (the type we use).
    //  We configure each ADC to start converting based on a trigger from an
    //  external source.  We direct them to scan all of their input channels.
    //  Finally we will use the DMA controller to copy the result data to our
    //  buffers.  Note that the sequencer length must match the constant
    //  ADCConstants::numberADCInputChannels.
    //
    LL_ADC_REG_InitTypeDef regularSampleSettings;
    LL_ADC_REG_StructInit(&regularSampleSettings);
    regularSampleSettings.SequencerLength  = LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS;
    regularSampleSettings.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
    regularSampleSettings.ContinuousMode   = LL_ADC_REG_CONV_SINGLE;
    regularSampleSettings.DMATransfer      = LL_ADC_REG_DMA_TRANSFER_LIMITED;

    //
    //  We can trigger the ADC from an external pin or we can trigger the ADC
    //  from the local PWM control timer.  If we are controlling the motor
    //  we should use the local PWM timer.  If we are monitoring the output of
    //  another motor controller, we should use the external pin.
    //
    if (!(SystemConfig::snoopRemoteMotorController))
    {
        regularSampleSettings.TriggerSource = ADCDefinitions::localPWMstartOfConversionTrigger;
    }
    else
    {
        //
        //  We must configure the external interrupt.  We don't need the interrupt
        //  but we do need the signal.
        //
        LL_EXTI_InitTypeDef externalTriggerConfig;
        LL_EXTI_StructInit(&externalTriggerConfig);

        externalTriggerConfig.Line_0_31   = LL_EXTI_LINE_11;
        externalTriggerConfig.LineCommand = ENABLE;
        externalTriggerConfig.Trigger     = LL_EXTI_TRIGGER_FALLING;
        externalTriggerConfig.Mode        = LL_EXTI_MODE_IT_EVENT;
        LL_EXTI_Init(&externalTriggerConfig);
        LL_EXTI_ClearFlag_0_31(LL_EXTI_LINE_11);
        LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTC, LL_SYSCFG_EXTI_LINE11);

        regularSampleSettings.TriggerSource = ADCDefinitions::externalstartOfConversionTrigger;
    }

    LL_ADC_REG_Init(ADCDefinitions::theADC1, &regularSampleSettings);
    LL_ADC_REG_Init(ADCDefinitions::theADC2, &regularSampleSettings);
    LL_ADC_REG_Init(ADCDefinitions::theADC3, &regularSampleSettings);


    //
    //  For now, we do not use the "injected group" feature.
    //
    LL_ADC_INJ_InitTypeDef injectedSampleSettings;
    LL_ADC_INJ_StructInit(&injectedSampleSettings);
    LL_ADC_INJ_Init(ADCDefinitions::theADC1, &injectedSampleSettings);
    LL_ADC_INJ_Init(ADCDefinitions::theADC2, &injectedSampleSettings);
    LL_ADC_INJ_Init(ADCDefinitions::theADC3, &injectedSampleSettings);

    //
    //  For now, we will sample each input for the same amount of time.  We sample the
    //  phase voltages first as we want them most close to the PWM center.
    //  We may alter this based on timing or hardware configurations.
    //
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC1, LL_ADC_REG_RANK_1, LL_ADC_CHANNEL_0);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC1, LL_ADC_REG_RANK_2, LL_ADC_CHANNEL_2);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC1, LL_ADC_REG_RANK_3, LL_ADC_CHANNEL_10);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC1, LL_ADC_REG_RANK_4, LL_ADC_CHANNEL_12);

    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC2, LL_ADC_REG_RANK_1, LL_ADC_CHANNEL_1);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC2, LL_ADC_REG_RANK_2, LL_ADC_CHANNEL_3);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC2, LL_ADC_REG_RANK_3, LL_ADC_CHANNEL_11);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC2, LL_ADC_REG_RANK_4, LL_ADC_CHANNEL_13);

    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC3, LL_ADC_REG_RANK_1, LL_ADC_CHANNEL_4);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC3, LL_ADC_REG_RANK_2, LL_ADC_CHANNEL_5);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC3, LL_ADC_REG_RANK_3, LL_ADC_CHANNEL_6);
    LL_ADC_REG_SetSequencerRanks(ADCDefinitions::theADC3, LL_ADC_REG_RANK_4, LL_ADC_CHANNEL_7);

    //
    //  We set the sample time for ALL channels even though we don't use them
    //  (right now).  If something gets changed, above, this will not need to
    //  be updated unless a different sample time is desired.
    //
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_0, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_1, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_2, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_3, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_4, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_5, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_6, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_7, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_8, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_9, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_10, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_11, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_12, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_13, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_14, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC1, LL_ADC_CHANNEL_15, LL_ADC_SAMPLINGTIME_3CYCLES);

    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_0, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_1, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_2, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_3, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_4, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_5, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_6, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_7, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_8, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_9, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_10, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_11, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_12, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_13, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_14, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC2, LL_ADC_CHANNEL_15, LL_ADC_SAMPLINGTIME_3CYCLES);

    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_0, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_1, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_2, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_3, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_4, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_5, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_6, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_7, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_8, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_9, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_10, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_11, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_12, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_13, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_14, LL_ADC_SAMPLINGTIME_3CYCLES);
    LL_ADC_SetChannelSamplingTime(ADCDefinitions::theADC3, LL_ADC_CHANNEL_15, LL_ADC_SAMPLINGTIME_3CYCLES);

    //
    //  We prepare the DMA.  The DMA will transfer each ADC result to our
    //  buffer and interrupt us when the transfer is complete.
    //
    LL_DMA_InitTypeDef dmaSettings;
    LL_DMA_StructInit(&dmaSettings);
    dmaSettings.Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
    dmaSettings.Mode                   = LL_DMA_MODE_NORMAL;
    dmaSettings.PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;
    dmaSettings.MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_INCREMENT;
    dmaSettings.PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_WORD;
    dmaSettings.MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_WORD;
    dmaSettings.NbData                 = ADCConstants::numberADCInputChannels;
    dmaSettings.Priority               = LL_DMA_PRIORITY_HIGH;
    dmaSettings.FIFOMode               = LL_DMA_FIFOMODE_DISABLE;
    dmaSettings.FIFOThreshold          = LL_DMA_FIFOTHRESHOLD_1_2;
    dmaSettings.MemBurst               = LL_DMA_MBURST_SINGLE;
    dmaSettings.PeriphBurst            = LL_DMA_PBURST_SINGLE;

    dmaSettings.PeriphOrM2MSrcAddress  = reinterpret_cast<uint32_t>(&(ADCDefinitions::theADC1->DR));
    dmaSettings.MemoryOrM2MDstAddress  = reinterpret_cast<uint32_t>(adc1DataBuffer);
    dmaSettings.Channel                = DMADefinitions::ADC1DMAChannel;
    LL_DMA_Init(DMADefinitions::ADCDMA, DMADefinitions::ADC1DMAStream, &dmaSettings);

    dmaSettings.PeriphOrM2MSrcAddress  = reinterpret_cast<uint32_t>(&(ADCDefinitions::theADC2->DR));
    dmaSettings.MemoryOrM2MDstAddress  = reinterpret_cast<uint32_t>(adc2DataBuffer);
    dmaSettings.Channel                = DMADefinitions::ADC2DMAChannel;
    LL_DMA_Init(DMADefinitions::ADCDMA, DMADefinitions::ADC2DMAStream, &dmaSettings);

    dmaSettings.PeriphOrM2MSrcAddress  = reinterpret_cast<uint32_t>(&(ADCDefinitions::theADC3->DR));
    dmaSettings.MemoryOrM2MDstAddress  = reinterpret_cast<uint32_t>(adc3DataBuffer);
    dmaSettings.Channel                = DMADefinitions::ADC3DMAChannel;
    LL_DMA_Init(DMADefinitions::ADCDMA, DMADefinitions::ADC3DMAStream, &dmaSettings);

    //
    //  We do this last as some of the initializations will not complete if the
    //  ADC is enabled.
    //
    LL_ADC_Enable(ADCDefinitions::theADC1);
    LL_ADC_Enable(ADCDefinitions::theADC2);
    LL_ADC_Enable(ADCDefinitions::theADC3);

    //
    //  That's all for now.  We'll start things when commanded to do so.
    //
}

////////////////////////////////////////////////////////////////////////////////
//
//  This starts the flow of ADC data.  This includes enabling the ADC, DMA,
//  and the DMA's ADC-data-is-ready interrupt.  In addition, the ISR for the
//  data-ready interrupt is enabled.
//
////////////////////////////////////////////////////////////////////////////////
void ADCInterface::startADCCollections()
{
    memset (adc1DataBuffer, 0U, sizeof(adc1DataBuffer));
    memset (adc2DataBuffer, 0U, sizeof(adc2DataBuffer));
    memset (adc3DataBuffer, 0U, sizeof(adc3DataBuffer));

    //
    //  We start by enabling servicing of the DMA's data-ready interrupt.  We
    //  only use the interrupt from one of the ADCs.  We assume that they will
    //  all finish at about the same time.
    //
    const uint32_t prioritygroup = NVIC_GetPriorityGrouping();
    NVIC_SetPriority(DMA2_Stream0_IRQn, NVIC_EncodePriority(prioritygroup, 1U, 0U));
    NVIC_EnableIRQ(DMA2_Stream0_IRQn);

    //
    //  Now we clear and then enable the DMA's interrupt.
    //
    LL_DMA_ClearFlag_TC0(DMADefinitions::ADCDMA);
    LL_DMA_EnableIT_TC(DMADefinitions::ADCDMA, DMADefinitions::ADC3DMAStream);

    //
    //  Finally, we command the data collection.
    //
    commandADCDataCollection();
}

////////////////////////////////////////////////////////////////////////////////
//
//  This is called by the data ready ISR when new data is available from
//  the DMA controller.  It copies the data from the DMA's buffer, commands
//  the next data collection and then invokes the motor controller.
//
////////////////////////////////////////////////////////////////////////////////
void ADCInterface::processADCDataReady()
{
    using namespace ADCDefinitions;
    using namespace DMADefinitions;

    const tickTime_us maxTimeToWaitForADCComplete = 5U;
    tickTime_us startTime = theTimers.getHighResTime();
    do
    {
        if (theTimers.getHighResDelta(startTime) > maxTimeToWaitForADCComplete)
        {
            //
            //  We did not see all ADCs complete in time...we exit and hope
            //  for the best.
            //
            break;
        }
    }
    while (!(LL_DMA_IsActiveFlag_TC0(DMADefinitions::ADCDMA) &&
             LL_DMA_IsActiveFlag_TC2(DMADefinitions::ADCDMA) &&
             LL_DMA_IsActiveFlag_TC4(DMADefinitions::ADCDMA)));

    //
    //  We disable the DMAs and the ADCs.
    //
    LL_DMA_DisableStream(ADCDMA, ADC1DMAStream);
    LL_ADC_REG_SetDMATransfer(theADC1, LL_ADC_REG_DMA_TRANSFER_NONE);
    LL_ADC_REG_StopConversionExtTrig(theADC1);

    LL_DMA_DisableStream(ADCDMA, ADC2DMAStream);
    LL_ADC_REG_SetDMATransfer(theADC2, LL_ADC_REG_DMA_TRANSFER_NONE);
    LL_ADC_REG_StopConversionExtTrig(theADC2);

    LL_DMA_DisableStream(ADCDMA, ADC3DMAStream);
    LL_ADC_REG_SetDMATransfer(theADC3, LL_ADC_REG_DMA_TRANSFER_NONE);
    LL_ADC_REG_StopConversionExtTrig(theADC3);

    //
    //  We invoke the motor controller.  It will command the next data update.
    //
    theMotorController.updateMotorController();

}

////////////////////////////////////////////////////////////////////////////////
//
//  This provides access to the most recently collected motor control data.
//  This should be called soon after processADCDataReady is called but before
//  commandADCDataCollection is called.
//
////////////////////////////////////////////////////////////////////////////////
void ADCInterface::getRawMotorData(rawMotorData &newMotorData)
{
    using namespace ADCConstants;
    //
    //  We fill in the provided structure.
    //
    newMotorData.currentA   = adc1DataBuffer[phaseACurrent];
    newMotorData.currentB   = adc2DataBuffer[phaseBCurrent];
    newMotorData.currentC   = adc3DataBuffer[phaseCCurrent];
    newMotorData.voltageA   = adc1DataBuffer[phaseAVoltage];
    newMotorData.voltageB   = adc2DataBuffer[phaseBVoltage];
    newMotorData.voltageC   = adc3DataBuffer[phaseCVoltage];
    newMotorData.busVoltage = adc1DataBuffer[busVoltage];
    newMotorData.busCurrent = adc2DataBuffer[busCurrent];
}

////////////////////////////////////////////////////////////////////////////////
//
//  This provides access to the most recently collected hall sensor inputs
//  if they are present.
//
////////////////////////////////////////////////////////////////////////////////
void ADCInterface::getRawAnalogHallInputs(
    rawADCCounts &hallA,
    rawADCCounts &hallB,
    rawADCCounts &hallC)
{
    using namespace ADCConstants;
    //
    //  We fill in the provided data items.
    //
    hallA   = adc1DataBuffer[analogHallA];
    hallB   = adc2DataBuffer[analogHallB];
    hallC   = adc3DataBuffer[analogHallC];
}


////////////////////////////////////////////////////////////////////////////////
//
//  This commands the next ADC data collection.  The data will be collected
//  when the next trigger is received.
//
////////////////////////////////////////////////////////////////////////////////
void ADCInterface::commandADCDataCollection()
{
    using namespace ADCDefinitions;
    using namespace DMADefinitions;

    //
    //  We clear out any flags from any prior data collections.
    //
    const uint32_t clearAllDMAStream0n2Interrupts =
        (DMA_LIFCR_CTCIF0  | DMA_LIFCR_CHTIF0 | DMA_LIFCR_CTEIF0 |
         DMA_LIFCR_CDMEIF0 | DMA_LIFCR_CFEIF0 |
         DMA_LIFCR_CTCIF2  | DMA_LIFCR_CHTIF2 | DMA_LIFCR_CTEIF2 |
         DMA_LIFCR_CDMEIF2 | DMA_LIFCR_CFEIF2);
    const uint32_t clearAllDMAStream4Interrupts =
        (DMA_HIFCR_CTCIF4  | DMA_HIFCR_CHTIF4 | DMA_HIFCR_CTEIF4 |
         DMA_HIFCR_CDMEIF4 | DMA_HIFCR_CFEIF4);
    ADCDMA->LIFCR |= clearAllDMAStream0n2Interrupts;
    ADCDMA->HIFCR |= clearAllDMAStream4Interrupts;

    const uint32_t clearAllADCFlags =
        (LL_ADC_FLAG_STRT | LL_ADC_FLAG_EOCS | LL_ADC_FLAG_OVR |
         LL_ADC_FLAG_JSTRT | LL_ADC_FLAG_JEOS | LL_ADC_FLAG_AWD1);
    theADC1->SR &= ~(clearAllADCFlags);
    theADC2->SR &= ~(clearAllADCFlags);
    theADC3->SR &= ~(clearAllADCFlags);

    //
    //  If we are using the external ADC trigger, we clear it.
    //
    if (SystemConfig::snoopRemoteMotorController)
    {
        LL_EXTI_ClearFlag_0_31(LL_EXTI_LINE_11);
    }

    //
    //  Now we enable the DMA and the ADC's requests to the DMA.
    //
    LL_DMA_EnableIT_TC(ADCDMA, ADC1DMAStream);
    LL_DMA_EnableStream(ADCDMA, ADC1DMAStream);
    LL_ADC_REG_SetDMATransfer(theADC1, LL_ADC_REG_DMA_TRANSFER_LIMITED);
    LL_DMA_EnableIT_TC(ADCDMA, ADC2DMAStream);
    LL_DMA_EnableStream(ADCDMA, ADC2DMAStream);
    LL_ADC_REG_SetDMATransfer(theADC2, LL_ADC_REG_DMA_TRANSFER_LIMITED);
    LL_DMA_EnableIT_TC(ADCDMA, ADC3DMAStream);
    LL_DMA_EnableStream(ADCDMA, ADC3DMAStream);
    LL_ADC_REG_SetDMATransfer(theADC3, LL_ADC_REG_DMA_TRANSFER_LIMITED);

    //
    //  All is ready, we enable sequencer and the trigger generated by the motor drive.
    //
    LL_ADC_REG_SetSequencerLength(theADC1, LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS);
    LL_ADC_REG_SetSequencerLength(theADC2, LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS);
    LL_ADC_REG_SetSequencerLength(theADC3, LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS);
    LL_ADC_REG_StartConversionExtTrig(theADC1, LL_ADC_REG_TRIG_EXT_FALLING);
    LL_ADC_REG_StartConversionExtTrig(theADC2, LL_ADC_REG_TRIG_EXT_FALLING);
    LL_ADC_REG_StartConversionExtTrig(theADC3, LL_ADC_REG_TRIG_EXT_FALLING);

}

////////////////////////////////////////////////////////////////////////////////
//
//  This is the ISR that is triggered when new data is available.
//
////////////////////////////////////////////////////////////////////////////////
void DMA2_Stream0_IRQHandler(void)
{
    SystemConfig::turnTimingLEDOnForEvent(SystemConfig::timeADCInterrupt);

    theADCInterface.processADCDataReady();

    SystemConfig::turnTimingLEDOffForEvent(SystemConfig::timeADCInterrupt);
}

